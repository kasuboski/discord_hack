"""Conversation store for tracking message history and conversation threads.

Implements passive message storage without routing logic.
Messages are stored for future context selection.
"""

from dataclasses import dataclass, field
from datetime import datetime, UTC

import discord


@dataclass
class ConversationMessage:
    """Represents a message in conversation history.

    This is our internal representation that decouples from Discord's API.
    All Discord messages are converted to this format at the boundary (on_message).
    """

    # Core message data
    id: str  # Discord message ID
    author_name: str
    author_id: str
    content: str
    timestamp: datetime
    channel_id: str  # Channel where message was sent

    # Bot-specific metadata
    is_bot: bool
    persona_name: str | None  # If bot message, which persona sent it

    # Conversation threading metadata (critical for router)
    reply_to_id: str | None  # If replying to another message, its ID
    mentions_user_ids: list[str]  # User IDs mentioned in message (for @Bob detection)

    # Rich content indicators (for context understanding)
    has_attachments: bool  # Images, files, etc.
    attachment_types: list[str]  # e.g., ["image/png", "application/pdf"]
    has_embeds: bool  # Rich embeds

    @classmethod
    def from_discord_message(
        cls, message: discord.Message, persona_name: str | None = None
    ) -> "ConversationMessage":
        """Convert Discord message to internal representation.

        This is the ONLY place we extract data from discord.Message.
        After this conversion, we work purely with ConversationMessage.

        Args:
            message: Discord message to convert
            persona_name: If bot message, which persona sent it

        Returns:
            ConversationMessage instance
        """
        return cls(
            id=str(message.id),
            author_name=message.author.display_name,
            author_id=str(message.author.id),
            content=message.content,
            timestamp=message.created_at,
            channel_id=str(message.channel.id),
            is_bot=message.author.bot,
            persona_name=persona_name,
            reply_to_id=(
                str(message.reference.message_id) if message.reference else None
            ),
            mentions_user_ids=[str(u.id) for u in message.mentions],
            has_attachments=len(message.attachments) > 0,
            attachment_types=[a.content_type or "unknown" for a in message.attachments],
            has_embeds=len(message.embeds) > 0,
        )


@dataclass
class ConversationThread:
    """Represents an ongoing conversation thread."""

    id: str  # Generated conversation ID
    channel_id: str
    created_at: datetime
    last_active: datetime
    messages: list[ConversationMessage] = field(default_factory=list)
    topic_summary: str | None = None  # Generated by LLM (future)

    def get_recent_messages(self, limit: int = 20) -> list[ConversationMessage]:
        """Get most recent messages for router context.

        Args:
            limit: Maximum number of messages to return

        Returns:
            List of most recent messages (up to limit)
        """
        return self.messages[-limit:]

    def is_stale(self, threshold_minutes: int = 30) -> bool:
        """Check if conversation is stale (inactive).

        Args:
            threshold_minutes: Minutes of inactivity to consider stale

        Returns:
            True if conversation is stale, False otherwise
        """
        return (
            datetime.now(UTC) - self.last_active
        ).total_seconds() > threshold_minutes * 60

    def get_message_by_id(self, message_id: str) -> ConversationMessage | None:
        """Find a message in this conversation by ID.

        Args:
            message_id: ID of message to find

        Returns:
            ConversationMessage if found, None otherwise
        """
        for msg in self.messages:
            if msg.id == message_id:
                return msg
        return None

    def add_message(self, message: ConversationMessage) -> None:
        """Add a message to this conversation thread.

        Args:
            message: ConversationMessage to add
        """
        self.messages.append(message)
        self.last_active = datetime.now(UTC)


class ConversationStore:
    """Manages conversation threads and message history.

    Stores all messages passively in conversation threads per channel.
    """

    def __init__(
        self,
        max_conversations: int = 100,
        max_messages_per_conversation: int = 200,
    ):
        """Initialize conversation store.

        Args:
            max_conversations: Maximum number of conversations to track
            max_messages_per_conversation: Maximum messages per conversation
        """
        self.conversations: dict[str, ConversationThread] = {}
        self.channel_conversations: dict[
            str, list[str]
        ] = {}  # channel_id -> conversation_ids
        self.max_conversations = max_conversations
        self.max_messages = max_messages_per_conversation

    def get_active_conversations(self, channel_id: str) -> list[ConversationThread]:
        """Get all active (non-stale) conversations in a channel.

        Args:
            channel_id: Discord channel ID

        Returns:
            List of active ConversationThread objects
        """
        conv_ids = self.channel_conversations.get(channel_id, [])
        return [
            self.conversations[cid]
            for cid in conv_ids
            if cid in self.conversations and not self.conversations[cid].is_stale()
        ]

    def create_conversation(
        self, channel_id: str, initial_message: ConversationMessage
    ) -> ConversationThread:
        """Create a new conversation thread.

        Args:
            channel_id: Discord channel ID
            initial_message: First message in the conversation

        Returns:
            Newly created ConversationThread
        """
        conv_id = f"{channel_id}_{datetime.now(UTC).timestamp()}"
        conv = ConversationThread(
            id=conv_id,
            channel_id=channel_id,
            created_at=datetime.now(UTC),
            last_active=datetime.now(UTC),
            messages=[initial_message],
            topic_summary=None,
        )

        self.conversations[conv_id] = conv
        if channel_id not in self.channel_conversations:
            self.channel_conversations[channel_id] = []
        self.channel_conversations[channel_id].append(conv_id)

        self._cleanup_old_conversations()
        return conv

    def add_message(self, conversation_id: str, message: ConversationMessage) -> None:
        """Add message to existing conversation.

        Args:
            conversation_id: ID of conversation to add message to
            message: ConversationMessage to add
        """
        if conversation_id in self.conversations:
            conv = self.conversations[conversation_id]
            conv.messages.append(message)
            conv.last_active = datetime.now(UTC)

            # Trim messages if exceeding limit
            if len(conv.messages) > self.max_messages:
                conv.messages = conv.messages[-self.max_messages :]

    def get_conversation(self, conversation_id: str) -> ConversationThread | None:
        """Get a specific conversation by ID.

        Args:
            conversation_id: ID of conversation to retrieve

        Returns:
            ConversationThread if found, None otherwise
        """
        return self.conversations.get(conversation_id)

    def get_or_create_conversation(
        self, channel_id: str, message: ConversationMessage
    ) -> ConversationThread:
        """Get existing conversation for channel or create new one.

        Args:
            channel_id: Discord channel ID
            message: Message to add to conversation

        Returns:
            ConversationThread for this channel
        """
        # Simple approach - one conversation per channel
        active_convs = self.get_active_conversations(channel_id)

        if active_convs:
            # Use first active conversation
            conv = active_convs[0]
            self.add_message(conv.id, message)
            return conv
        else:
            # No active conversation, create new one
            return self.create_conversation(channel_id, message)

    def _cleanup_old_conversations(self) -> None:
        """Remove stale conversations when limit exceeded."""
        if len(self.conversations) > self.max_conversations:
            # Remove oldest stale conversations
            stale = [
                (cid, conv.last_active)
                for cid, conv in self.conversations.items()
                if conv.is_stale()
            ]
            stale.sort(key=lambda x: x[1])

            for cid, _ in stale[: len(stale) // 2]:
                del self.conversations[cid]
                # Clean up channel index
                for channel_id, conv_ids in self.channel_conversations.items():
                    if cid in conv_ids:
                        conv_ids.remove(cid)


# Global instance
_conversation_store: ConversationStore | None = None


def get_conversation_store() -> ConversationStore:
    """Get global conversation store instance.

    Returns:
        Global ConversationStore instance
    """
    global _conversation_store
    if _conversation_store is None:
        _conversation_store = ConversationStore()
    return _conversation_store
